#include "controllerPDOrient.hpp"

using namespace std;


double negativeSaturate(double value)
{
	if (value<0) value=0;
	return value;
}


/*
Implementation of loop function for computations in this specific POD
*/

bool controllerPDOrient_t::doComputations()
{
    controllerPDOrient_t* podWorker = this;
    std::lock_guard<std::mutex> guard(podMutex);
    /*--------*/

    /* Computations */

    //compute euler angle estimate from quaternion estimates
    double yaw_hat, pitch_hat, roll_hat;
    quat2Euler(stateVariances.orient, &(yaw_hat), &(pitch_hat), &(roll_hat));

    //printf("orient estim: %f %f %f\n",yaw_hat,pitch_hat,roll_hat);

    double tau_p 		= powerAdjust.ppAdjustPDO * Pp * (poseRef.orientEuler[1] - pitch_hat) - powerAdjust.dpAdjustPDO * Dp * stateVariances.veloOrientBody[1] + powerAdjust.pBiasPDO; //@TODO check convention, see PODdescriptions!
    double tau_r 		= powerAdjust.prAdjustPDO * Pr * (poseRef.orientEuler[2] - roll_hat)  - powerAdjust.drAdjustPDO * Dr * stateVariances.veloOrientBody[0] + powerAdjust.rBiasPDO;
    double tau_y 		= powerAdjust.pyAdjustPDO * Py * (poseRef.orientEuler[0] - yaw_hat)   - powerAdjust.dyAdjustPDO * Dy * stateVariances.veloOrientBody[2] + powerAdjust.yBiasPDO;
    double totalThrust = - QUADMASS * GRAVITY - powerAdjust.tBiasPDO; //- because thrust "upwards" is equals negative thrust! @TODO add altitude control?

    //printf("%f \n",powerAdjust.tBiasPDO);

    //printf("%f \n",poweradjust.totalthrustGain);
    //control mixer that translates into required RPM (note: this is not too sound, desired torque generated by PD should translate via sqrt-function to RPM, not linearly, but it works (on Parrot's RS with MIT ROSMAT)


    //printf("delay estimated state to now: %f\n",(GetTimeStamp()-stateVariances.timestampJetson)/1000000.0);

    motorsWsRef.wsRef[0] = sqrt(negativeSaturate(-THRUST2OMEGA2 * (ATOTALTHRUST * totalThrust + ATAUYAW * tau_y - ATAUPR * tau_p - ATAUPR * tau_r)));
    motorsWsRef.wsRef[1] = sqrt(negativeSaturate(-THRUST2OMEGA2 * (ATOTALTHRUST * totalThrust - ATAUYAW * tau_y - ATAUPR * tau_p + ATAUPR * tau_r)));
    motorsWsRef.wsRef[2] = sqrt(negativeSaturate(-THRUST2OMEGA2 * (ATOTALTHRUST * totalThrust + ATAUYAW * tau_y + ATAUPR * tau_p + ATAUPR * tau_r)));
    motorsWsRef.wsRef[3] = sqrt(negativeSaturate(-THRUST2OMEGA2 * (ATOTALTHRUST * totalThrust - ATAUYAW * tau_y + ATAUPR * tau_p - ATAUPR * tau_r)));
   

    motorsWsRef.timestampJetson = GetTimeStamp();

    /*---------*/


    /* Publishing */

    // statusDrone - publish
    lcm.publish("motorsWsRefPDOrient", &motorsWsRef); 	//choose channelName here!

    /*---------*/



    /*General Infrastructure (maintain this structure!)*/
    updateComputationInterval();
    return TRUE;
    /*---------*/
}
/*--------------------------*/





/*
Implementation of loop function for publishing statusPod
*/

bool controllerPDOrient_t::updateStatus()
{
    controllerPDOrient_t* podWorker = this;
    messageStatus_t messageStatus = checkMessagesUptodate();
    std::lock_guard<std::mutex> guard(podMutex);
    /*---------*/

    /*Computation statusPOD*/

    if(computationInterval > MAXPODDELAY_X * callInterval * MS2US)
    {
        printf("%s: delay in computation, dt=% " PRId64 "us at t=%" PRId64 "!\n", podName.c_str(), computationInterval,GetTimeStamp());
        statusPod.status = POD_FATAL;
    }
    else 
    {

	if(messageStatus == MSGS_LATE)
    	{
		statusPod.status = POD_CRITICAL;
	}
	else if(messageStatus == MSGS_DEAD)
	{
		statusPod.status = POD_FATAL;
	}
	else
	{
		statusPod.status = POD_OK;
	};

    };



    /*---------*/

    /*Publishing statusPOD (keep this infrastructure!)*/
    publishStatus(statusPod.status);
    /*---------*/

    return TRUE;
};
/*--------------------------*/




/*
main to initialize and start the POD
*/

int main(int argc, char** argv)
{

    /* General Infrastructure: setup (maintain this structure!)  */

    // 1) Create the app
    controllerPDOrient_t podWorker = controllerPDOrient_t("controllerPDOrient", CALLINTERVAL_CONTROLLERPDORIENT); 	//provide your PODname here!

    if(argc < 2)
    {
        printf("Please provide estimationChannel that controller will use!\n");
        return EXIT_FAILURE;
    };

    podWorker.stateVariancesChannel = argv[1];

    // 2) Create LCM
    if(!podWorker.lcm.good())
        return 1;

    // 3) Subscribe this POD to channels
    if(podWorker.stateVariancesChannel == "stateVariancesOrientV1")
        podWorker.subscribe(podWorker.stateVariancesChannel, CALLINTERVAL_STATEESTIMATORORIENTV1, 	 &(podWorker.stateVariances), 	&podBase_t::handleMessage<agile::stateVariances_t>);
    else if(podWorker.stateVariancesChannel == "stateVariancesOrientCF")
        podWorker.subscribe(podWorker.stateVariancesChannel, CALLINTERVAL_STATEESTIMATORORIENTCF, 	 &(podWorker.stateVariances), 	&podBase_t::handleMessage<agile::stateVariances_t>);
    else podWorker.subscribe(podWorker.stateVariancesChannel, CALLINTERVAL_SIMULATOR, 	 &(podWorker.stateVariances), 	&podBase_t::handleMessage<agile::stateVariances_t>);

    podWorker.subscribe("poseRef",  CALLINTERVAL_REMOTECONTROLLER*AGEMSG_X_TUNNEL, &(podWorker.poseRef), &podBase_t::handleMessage<agile::poseRef_t>);
    podWorker.subscribe("powerAdjust",  CALLINTERVAL_REMOTECONTROLLER*AGEMSG_X_TUNNEL, &(podWorker.powerAdjust), &podBase_t::handleMessage<agile::powerAdjust_t>);

    /*---------*/




    /*  POD-specific init procedures  */
    // Update and publish status of controllerPDOrient_t (this POD is the first to start)
    podWorker.publishStatus(POD_INITING);

    /*---------*/



    /*  General Infrastructure: loops (maintain this structure!)  */

    //  POD-wait for watchdogPOD to be up and running (POD_OK)  before continue

    printf("Waiting for watchdog to be POD_OK...\n");
    while(podWorker.statusWatchdog.status != POD_OK)
    {
        podWorker.lcm.handle();
    }
    printf("Watchdog POD_OK! Continuing...\n");
    podWorker.initComputationInterval();

    //Create message listener thead
    std::thread listenerThread(listen, &podWorker);

    // Create mainloop, add loop functions, run
    GMainLoop* mainloop = g_main_loop_new(NULL, FALSE);

    guint timerComputations = g_timeout_add(podWorker.callInterval, podBase_t::gtimerfuncComputations, (gpointer)&podWorker);
    guint timerStatusPod =    g_timeout_add(podWorker.callInterval, podBase_t::gtimerfuncStatusPod, (gpointer)&podWorker);

    g_main_loop_run(mainloop);

    /*---------*/

    return 0;
}
